
import { Pipeline, PipelineParameter, NextflowProcess } from '../types';

const generateParameterLines = (params: PipelineParameter[]): string => {
  if (params.length === 0) return "// No parameters defined\n";
  return params.map(p => {
    let line = `params.${p.name} = `;
    if (p.type === 'string' || p.type === 'path' || p.type === 'file' || p.type === 'directory') {
      line += `"${p.defaultValue || ''}"`;
    } else if (p.type === 'integer') {
      line += `${p.defaultValue || '0'}`;
    } else if (p.type === 'boolean') {
      line += `${p.defaultValue === 'true' || p.defaultValue === 'on' ? 'true' : 'false'}`;
    } else {
      line += `"${p.defaultValue || ''}"`; // Default to string if type is unknown
    }
    if (p.description) {
      line += ` // ${p.description}`;
    }
    return line;
  }).join('\n') + '\n';
};

const generateProcessBlock = (proc: NextflowProcess): string => {
  let block = `process ${proc.name.toUpperCase().replace(/\s+/g, '_')} {\n`;
  if (proc.description) {
    block += `    // ${proc.description}\n`;
  }

  if (proc.directiveDeclarations && proc.directiveDeclarations.trim() !== "") {
    proc.directiveDeclarations.split('\n').forEach(line => {
      if (line.trim() !== "") block += `    ${line.trim()}\n`;
    });
  } else {
     block += `    // tag { "${proc.name}" } // Example: tag { sample_id }\n`
  }
  
  block += `\n`;

  if (proc.inputDeclarations && proc.inputDeclarations.trim() !== "") {
    block += `    input:\n`;
    proc.inputDeclarations.split('\n').forEach(line => {
      if (line.trim() !== "") block += `    ${line.trim()}\n`;
    });
  } else {
    block += `    // input:\n    // val x\n`;
  }
  
  block += `\n`;

  if (proc.outputDeclarations && proc.outputDeclarations.trim() !== "") {
    block += `    output:\n`;
    proc.outputDeclarations.split('\n').forEach(line => {
      if (line.trim() !== "") block += `    ${line.trim()}\n`;
    });
  } else {
    block += `    // output:\n    // path 'output_file.txt'\n`;
  }
  
  block += `\n`;

  block += `    script:\n`;
  if (proc.script && proc.script.trim() !== "") {
    // Ensure script is properly quoted with triple quotes
    // Escape any internal triple quotes if necessary, though rare in shell scripts
    const escapedScript = proc.script.replace(/"""/g, `""\\"`);
    block += `    """\n${escapedScript.split('\n').map(line => `    ${line}`).join('\n')}\n    """\n`;
  } else {
    block += `    """\n    // Your script commands here\n    echo "Processing ..." > ${proc.name.toLowerCase()}_output.txt\n    """\n`;
  }
  
  block += `}\n`;
  return block;
};

const generateProcesses = (processes: NextflowProcess[]): string => {
  if (processes.length === 0) return "// No processes defined\n";
  return processes.map(generateProcessBlock).join('\n');
};

export const generateNextflowScript = (pipeline: Pipeline): string => {
  const header = `#!/usr/bin/env nextflow
nextflow.enable.dsl=2

/*
========================================================================================
    ${pipeline.name || 'My Nextflow Pipeline'}
========================================================================================
    Description : ${pipeline.description || 'A pipeline generated by Nextflow Pipeline Builder.'}
    Version     : ${pipeline.version || '1.0.0'}
    Author      : Nextflow Pipeline Builder User
----------------------------------------------------------------------------------------
*/

// Log & Parameters
// ========================================================================================
log.info """
         P I P E L I N E    N A M E    --    ${pipeline.name || 'MY_PIPELINE'}
         ===================================
         version         : \${workflow.manifest.version}
         description     : \${workflow.manifest.description}
         params.outdir   : \${params.outdir ?: '.'}
         """
         .stripIndent()

// Default parameters
params.outdir = './results' // Default output directory
`;

  const paramsSection = generateParameterLines(pipeline.parameters);
  const processesSection = generateProcesses(pipeline.processes);
  const workflowSection = `// Workflow
// ========================================================================================
workflow ${pipeline.name ? pipeline.name.toUpperCase().replace(/\s+/g, '_') : 'MAIN'} {
    // Example: MY_PROCESS_1 ( Channel.fromPath(params.input_file) )
    // MY_PROCESS_2 ( MY_PROCESS_1.out.some_output_channel )
${pipeline.workflowContent || '    // Define your workflow logic here by calling processes and connecting channels.'}
}
`;
  
  return `${header}\n${paramsSection}\n${processesSection}\n${workflowSection}`;
};

export const generateNextflowConfig = (pipeline: Pipeline): string => {
  const header = `/*
========================================================================================
    Nextflow Configuration File for ${pipeline.name || 'My Nextflow Pipeline'}
========================================================================================
*/

// Default Process Configuration
// ========================================================================================
process {
    cpus   = { check_max( 1 * task.attempt, 'cpus' ) }
    memory = { check_max( 6.GB * task.attempt, 'memory' ) }
    time   = { check_max( 4.h * task.attempt, 'time' ) }

    errorStrategy = { task.attempt < 2 ? 'retry' : 'finish' }
    maxRetries    = 1
    maxErrors     = '-1' // Allow all errors to be collected for the report

    // Default container image
    // container = 'your-docker-or-singularity-container'
}

// Profiles (example)
// ========================================================================================
profiles {
    standard {
        process.executor = 'local'
    }
    docker {
        docker.enabled = true
        // docker.runOptions = '-u \$(id -u):\$(id -g)' // Optional: run as current user
    }
    singularity {
        singularity.enabled = true
        singularity.autoMounts = true
    }
    cloud {
        process.executor = 'awsbatch' // or 'google-lifesciences', 'azurebatch'
        // Add cloud specific configurations here
    }
}

// Helper function to check resource limits
// ========================================================================================
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### WARN: Groovy SORRY language, returning default memory --> \${obj}"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### WARN: Groovy SORRY language, returning default time --> \${obj}"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### WARN: Groovy SORRY language, returning default cpus --> \${obj}"
            return obj
        }
    }
}

// Custom Configuration
// ========================================================================================
// Add your custom configuration from the UI below
`;

  return `${header}\n\n${pipeline.nextflowConfigContent || '// No custom configuration provided.'}`;
};

    